# Сравнение подходов к построению рекомендательной системы на основе данных movielens20M
## Метрика
Метрика, по которой будет оцениваться модель должна отвечать запросам бизнеса, так как в задаче нет конкретных бизнес-требований, то остается предположить какие задачи будущая рекомендательная система должна решать. Если предполагать, что задача заключается в том, чтобы пользователь заходя на сервис, не тратил много времени в поисках фильма для просмотра и не покинул сервис, а сразу же получал в рекомендации фильм, который он захочет посмотреть, то рекомендации должны быть наиболее релевантны и в первую очередь предлагаться должны наиболее подходящие фильмы. Для оценки релевантности рекомендаций в качестве метрики для модели, я считаю целесообразным выбрать nDCG@k, эта метрика позволяет оценить релевантность рекомендаций, который получает пользователь, а также учитывает позиции релевантных объектов. Для того, чтобы рассчитывать данную метрику можно использовать следующую стратегию разбиения на train/test: для каждого пользователя выбрать N случайных фильмов, которым он поставил оценку, все остальные фильмы отправить в трейн. таким образом для каждого пользователя будет сформирован список из N фильмов, которые будут считаться релевантными. Затем после составления рекомендаций для каждого пользователя из M фильмов, отметить как 0 нерелевантные фильмы и как 1-релевантные, получим список типа [0, 1, 0, 0, 0, ... ] и после этого рассчитывается метрика nDCG@M для каждого пользователя, затем усредняется по всем пользователям. Я решил взять nDCG@20, так как посчитал, что 20-это разумное число фильмов, которое может пользователь рассмотреть перед просмотром.

## Разбиение на train/test
Данные первым делом фильтруются: сначала удаляются фильмы с суммарным количеством оценок меньше 10, а затем пользователи с количеством оценок меньше 100.
Для разбивки на трейн/тест берутся 30 случайных оценок фильмов каждого пользователя. Используя такую разбивку, по сути, мы делаем вид, что пользователи поставили эти 30 оценок после самой последней оценки трейна и если предположить, что вкусы пользователей не меняется, то небольшое заглядывание в будущее (имется в виду тот факт, что оценка фильму в тесте могла быть поставлена раньше других оценок в трейне, то есть на тот момент были еще неизвестны оценки, на основании которых в конечном итоге строится рекомендация) не является критичным.

### Содержание ноутбуков

#### Preparing_Data.ipynb
Очистка и подготовка данных. Сохранение train и test в csv файлы.

#### iALS.ipynb
Cодержит построение бейзлайна, на основе выдачи 20 самых популярных фильмов, которые пользователь не видел.
Построение модели iALS, подсчет ее метрики на test'е.

#### lightFM.ipynb 
Содержит функции обработки данных о фильмах. Построение ightFM моделей на основе отдельно тегов фильмов, жанров фильмов, а также модель использующая и теги, и жанры фильмов.

## Выводы
В конечном счете было получено четыре модели со следующим значением метрики nDCG@20 на тесте:

Baseline (выдача 20 самых популярных непросмотренных фильмов для каждого пользователя) - 0.131

Коллаборативная (implicitALS) скор на тесте - 0.423;

Коллаборативно-контентная (lightFM, где в качестве фичей жанры фильмов) - 0.346;

Коллаборативно-контентная (lightFM, где в качестве фичей самые релевантные теги фильмов) - 0.329;

Коллаборативно-контентная (lightFM, где в качестве фичей и жанры, и теги) - 0.312.

Как видно из метрик на тесте, и lightFM и implicit ALS смогли превзойти Baseline в несколько раз по метрике. При этом гораздо лучше остальных показала себя коллаборативная модель implicit ALS, из вариаций модели lightFM лучшей оказалась модель, в которой использовались только жанры фильмов. Тем не менее, есть предположение, что мне просто не удалось полностью реализовать потенциал lightFM.

#### P.S. Предположения по улучшению
Для улучшения lightFM нужен тонкий тюнинг гиперпараметров, это мне не удалось ввиду долгого обучения модели на таких больших данных, особенно учитывая, что для обучения нельзя установить многопоточность на Windows, что затрудняло подбор гиперпараметров.

